// vim: ts=4:sw=4:expandtab

(function() {
    'use strict';

    self.F = self.F || {};

    async function getMessage(receiptDesc) {
        const m = new F.Message({sent_at: receiptDesc.get('sent_at')});
        try {
            await m.fetch();
        } catch(e) {
            if (e.message !== 'Not Found') {
                throw e;
            }
            return;
        }
        /* Try to return the message instance used by current conversations.  Not
         * required but makes any action hence forth update the UI accordingly. */
        return m.getConversationMessage() || m;
    }

    F.Receipt = Backbone.Model.extend({
        database: F.Database,
        storeName: 'receipts'
    });

    F.ReceiptCollection = Backbone.Collection.extend({
        model: F.Receipt,
        database: F.Database,
        storeName: 'receipts',

        initialize: function(models, options) {
            this.message = options.message;
        },

        fetchAll: async function() {
            if (!this.message.id) {
                return;
            }
            await this.fetch({
                index: {
                    name  : 'message',
                    lower : this.message.id,
                    upper : this.message.id,
                }
            });
        },
    });

    F.deliveryReceiptQueue = new (Backbone.Collection.extend({
        /* TODO:  The only (meaningful) way to correlate these currently is by the
         * sent_at timestamp of the message.
         *
         * I think we may need to augment all clients to include a dataMessage along
         * with the syncMessage that includes various pieces of metadata.  Namely the
         * message id generated by the sender for perfect lookup. */

        initialize: function() {
            this.on('add', this.onAdd);
        },

        drain: function(message) {
            /* Drain receipts for a message model. */
            const receipts = this.where({sent_at: message.get('sent_at')});
            this.remove(receipts);
            return receipts;
        },

        onAdd: async function(receiptDesc) {
            const message = await getMessage(receiptDesc);
            if (!message) {
                return; // queue it.
            }
            await message.addDeliveryReceipt(receiptDesc);
            this.remove(receiptDesc);
        }
    }))();


    F.readReceiptQueue = new (Backbone.Collection.extend({
        initialize: function() {
            this.on('add', this.onAdd);
        },

        drain: function(message) {
            /* Drain receipts for a message model. */
            const receipts = this.where({sent_at: message.get('sent_at')});
            this.remove(receipts);
            return receipts;
        },

        onAdd: async function(receiptDesc) {
            const message = await getMessage(receiptDesc);
            if (!message) {
                return; // queue it.
            }
            await message.markRead(receiptDesc.get('read_at'));
            this.remove(receiptDesc);
        }
    }))();
})();

// vim: ts=4:sw=4:expandtab

(function() {
    'use strict';

    self.F = self.F || {};

    async function getMessage(receipt) {
        const m = new F.Message({sent_at: receipt.get('sent_at')});
        try {
            await m.fetch();
        } catch(e) {
            if (e.message !== 'Not Found') {
                throw e;
            }
            return;
        }
        // XXX try this without reloading from the convo message collection.
        const convo = await F.foundation.getConversations().get(m.get('conversationId'));
        return convo.messageCollection.get(m.id); // Get the wired instance.
    }

    F.deliveryReceiptQueue = new (Backbone.Collection.extend({
        /* TODO:  The only (meaningful) way to correlate these currently is by the
         * sent_at timestamp of the message.
         *
         * I think we may need to augment all clients to include a dataMessage along
         * with the syncMessage that includes various pieces of metadata.  Namely the
         * message id generated by the sender for perfect lookup. */

        initialize: function() {
            this.on('add', this.onAdd);
        },

        drain: function(message) {
            /* Drain receipts for a message model. */
            const receipts = this.where({sent_at: message.get('sent_at')});
            console.warn('draining', receipts.length);
            this.remove(receipts);
            return receipts;
        },

        onAdd: async function(receipt) {
            console.log("processing delivery receipt from", receipt);
            const message = await getMessage(receipt);
            if (!message) {
                console.warn("didn't find message for this guy,.. saving..", receipt.get('sent_at'));
                return;
            }
            message.addDeliveryReceipt(receipt);
            await message.save();
            this.remove(receipt);
        }
    }))();


    F.readReceiptQueue = new (Backbone.Collection.extend({
        initialize: function() {
            this.on('add', this.onAdd);
        },

        drain: function(message) {
            /* Drain receipts for a message model. */
            const receipts = this.where({sent_at: message.get('sent_at')});
            this.remove(receipts);
            return receipts;
        },

        onAdd: async function(receipt) {
            console.log("processing read receipt from", receipt.get('source'), receipt.get('sourceDevice'));
            const message = await getMessage(receipt);
            if (!message) {
                console.warn("didn't find message for this guy,.. huh..", receipt.get('sent_at'));
                return;
            }
            message.markRead(receipt.get('read_at'));
            await message.save();
            this.remove(receipt);
        }
    }))();
})();
